@Book{		  abadi.96.theory,
  author =	 {Mart{\'\i}n Abadi and Luca Cardelli},
  title =	 {A Theory of Objects},
  series =	 {Monographs in Computer Science},
  publisher =	 {Springer-Verlag},
  year =	 {1996}
}

@InProceedings{	  agesen.97.oopsla,
  author =	 {Ole Agesen and Stephen N. Freund and John
                  C. Mitchell},
  title =	 {Adding Type Parameterization to the {J}ava Language},
  booktitle =	 {In the Proceedings of the ACM Symposium on
                  Object-Oriented Programming Systems, Languages and
                  Applications (OOPSLA)},
  year =	 {1997},
  pages =	 {49--65},
  address =	 {Atlanta, GA, USA},
  month =	 {October}
}

@InProceedings{	  aigner.96.ecoop,
  author =	 {Gerald Aigner and Urs H{\"o}lzle},
  title =	 {Eliminating Virtual Function Calls in {C++}
                  Programs},
  booktitle =	 {In the Proceedings of the 10th European Conference
                  on Object-Oriented Programming (ECOOP)},
  series =	 {Lecture Notes in Computer Science},
  publisher =	 {Springer-Verlag},
  volume =	 {1098},
  pages =	 {142--167},
  year =	 {1996},
}

@Book{		  alexandrescu.01.book,
  author =	 {Andrei Alexandrescu},
  title =	 {Modern {C++} Design: Generic Programming and Design
                  Patterns Applied},
  publisher =	 {Addison-Wesley},
  year =	 {2001}
}

@InProceedings{	  bacon.96.oopsla,
  author =	 {David F. Bacon and Peter F. Sweeney},
  title =	 {Fast Static Analysis of {C++} Virtual Function
                  Calls},
  booktitle =	 {In the Proceedings of the ACM Conference on
                  Object-Oriented Programming Systems, Languages and
                  Applications (OOPSLA)},
  pages =	 {324--341},
  year =	 {1996},
  abstract =	 {Gives a peformance comparison for some extremely
                  simple static analyses (including CHA)}
}

@Book{		  barton.94.secpp,
  author =	 {John Barton and Lee Nackman},
  title =	 {Scientific and engineering {C++}},
  publisher =	 {Addison-Wesley},
  year =	 {1994},
}

@Article{	  baugmartner.97.tpls,
  author =	 {Gerald Baugmartner and Vincent F. Russo},
  title =	 {Implementing Signatures for {C++}},
  journal =	 {ACM Transactions on Programming Languages and
                  Systems},
  year =	 {1997},
  volume =	 {19},
  number =	 {1},
  pages =	 {153--187},
  month =	 {Juanary}
}

@Article{	  baumgartner.97.toplas,
  author =	 {Gerald Baumgartner and Vincent F. Russo},
  title =	 {Implementing Signatures for {C++}},
  journal =	 {ACM Transactions on Programming Languages and
                  Systems},
  year =	 {1997},
  volume =	 {19},
  number =	 {1},
  pages =	 {153--187},
  month =	 {January},
  abstract =	 {We outline the design and detail the implementation
                  of a language extension for abstracting types and
                  for decoupling subtyping and inheritance in
                  C++. This extension gives the user more of the
                  flexibility of dynamic typing while retaining the
                  efficiency and security of static typing. After a
                  brief discussion of syntax and semantics of this
                  language extension and examples of its use, we
                  present and analyze three different implementation
                  techniques: a preprocessor to a C++ compiler, an
                  implementation in the front end of a C++ compiler,
                  and a low-level implementation with back-end
                  support. We follow with an analysis of the
                  performance of the three implementation techniques
                  and show that our extension actually allows subtype
                  polymorphism to be implemented more efficiently than
                  with virtual functions. We conclude with a
                  discussion of the lessons we learned for future
                  programming language design.}
}

@InProceedings{	  bracha.98.oopsla,
  author =	 {Gilad Bracha and Martin Odersky and David Stoutamire
                  and Philip Wadler},
  title =	 {Making the Future Safe for the Past: Adding
                  Genericity to the {Java} Programming Language},
  booktitle =	 {In the Proceedings of the ACM Conference on
                  Object-Oriented Programming Systems, Languages and
                  Applications (OOPSLA)},
  address =	 {Vancouver, BC},
  editor =	 {Craig Chambers},
  pages =	 {183--200},
  year =	 {1998},
}

@Article{	  bruce.03.toplas,
  author =	 {Kim B. Bruce and Adrian Fiech and Angela Schuett and
                  Robert van Gent},
  title =	 {{PolyTOIL}: A Type-Safe Polymorphic Object-Oriented
                  Language},
  journal =	 {ACM Transactions on Programming Languages and
                  Systems (ToPLAS)},
  year =	 {2003},
  volume =	 {25},
  number =	 {2},
  pages =	 {225-290},
  month =	 {March}
}

@InProceedings{	  bruce.95.ecoop,
  author =	 {Kim B. Bruce and Angela Schuett and and Robert van
                  Gent},
  title =	 {{PolyTOIL}: A Type-Safe Polymorphic Object-Oriented
                  Language},
  booktitle =	 {In the Proceedings of the 9th European Conference on
                  Object-Oriented Programming (ECOOP)},
  year =	 {1995},
  address =	 {{\AA}arhus, Denmark},
  month =	 {August},
  pages =	 {27--51},
  volume =	 {952},
  publisher =	 {Springer-Verlag},
}

@Article{	  bruce.96.tapos,
  author =	 {Kim Bruce and Luca Cardelli and Giuseppe Castagna
                  and {The Hopkins Objects Group} and Gary T. Leavens
                  and Benjamin Pierce},
  title =	 {On Binary Methods},
  journal =	 {Theory and Practice of Object Systems},
  year =	 {1996},
  volume =	 {1},
  number =	 {3},
  pages =	 {221--242}
}

@Misc{		  bruce.96.typing,
  author =	 {Kim B. Bruce},
  title =	 {Typing in Object-oriented languages: Achieving
                  expressibility and Safety},
  year =	 {1996},
}

@InProceedings{	  bruce.97.ecoop,
  author =	 {Kim B. Bruce and Leaf Petersen and Adrian Fiech},
  title =	 {Subtyping Is Not a Good ``Match'' for Object-Oriented
                  Languages},
  booktitle =	 {In the Proceedings of the 11th European Conference
                  on Object-Oriented Programming (ECOOP)},
  year =	 {1997},
  pages =	 {104--127},
  volume =	 {1241},
  series =	 {Lecture Notes in Computer Science},
  address =	 {Jyv\"askyl\"a, Finland},
  publisher =	 {Springer-Verlag},
}

@InProceedings{	  bruce.98.ecoop,
  author =	 {Kim B. Bruce and Martin Odersky and Philip Wadler},
  title =	 {A Statically Safe Alternative to Virtual Types},
  volume =	 {1445},
  series =	 {Lecture Notes in Computer Science},
  pages =	 {523--549},
  booktitle =	 {In the Proceedings of the 12th European Conference
                  on Object-Oriented Programming (ECOOP)},
  address =	 {Brussels, Belgium},
  publisher =	 {Springer-Verlag},
  year =	 {1998},
  month =	 {July}
}

@InProceedings{	  canning.89.fpca,
  author =	 {Peter S. Canning and William R. Cook and Walter
                  L. Hill and John C. Mitchell and Walter G. Olthoff},
  title =	 {F-Bounded Polymorphism for Object-Oriented
                  Programming},
  booktitle =	 {In the Proceedings of the 4th International
                  Conference on Functional Programming Languages and
                  Computer Architecture (FPCA'89)},
  pages =	 {73--280},
  year =	 {1989},
  address =	 {London, UK},
  month =	 {September},
  publisher =	 {ACM},
}

@Article{	  cardelli.85.cs,
  author =	 {Luca Cardelli and Peter Wegner},
  title =	 {On Understanding Types, Data Abstraction, and
                  Polymorphism},
  journal =	 {Computing Surveys},
  year =	 {1985},
  volume =	 {17},
  number =	 {4},
  pages =	 {471--522},
  month =	 {December}
}

@TechReport{	  chambers.92.tr,
  author =	 {Craig Chambers},
  title =	 {The Design and Implementation of the {SELF}
                  Compiler},
  institution =	 {Department of Computer Science, Stanford University},
  year =	 {1992},
  number =	 {STAN-CS-92-1420},
  month =	 {March},
  abstract =	 {Specializing all methods (i.e. not choosing the
                  important ones with a profile) in SELF gives a
                  speedup of 1.5-5 times.}
}

@TechReport{	  chambers.96.tr,
  author =	 {Craig Chambers and Jeffrey Dean and David Grove},
  title =	 {Wholeprogram Optimization of Object-Oriented
                  Languages},
  institution =	 {University of Washington, Department of Computer
                  Science and Engineering},
  year =	 {1996},
  number =	 {UW-CSE-96-06-02},
  month =	 {June}
}

@InProceedings{cook.90.popl,
  author =	 {William R. Cook and Walter L. Hill and Peter
                  S. Canning},
  title =	 {Inheritance Is Not Subtyping},
  booktitle =	 {Conference Record of the 17th Annual ACM Symposium
                  on Principles of Programming Languages (POPL)},
  pages =	 {125--135},
  year =	 {1990},
  address =	 {San Francisco, California, USA},
  month =	 {January},
  note =	 {on l'a pas},
  abstract =	 {In typed object-oriented languages the subtype
                  relation is typically based on the inheritance
                  hierarchy. This approach, however, leads either to
                  insecure type-systems or to restrictions on
                  inheritance that make it less flexible than untyped
                  Smalltalk inheritance. We present a new typed model
                  of inheritance that allows more of the flexibility
                  of Smalltalk inheritance within a statically-typed
                  system. Significant features of our analysis are the
                  introduction of polymorphism into the typing of
                  inheritance and the uniform application of
                  inheritance to objects, classes and types. The
                  resulting notion of type inheritance allows us to
                  show that the type of an inherited object is an
                  inherited type but not always a subtype.}
}

@InBook{	  coplien.96.cppgems,
  author =	 {James Coplien},
  title =	 {Curiously Recurring Template Pattern},
  page =	 {135--144},
  note =	 {In~\cite{cppgems}}
}

@Book{		  cppgems,
  title =	 {{C++} Gems},
  editor =	 {Stanly B. Lippman},
  key =		 {cppgems},
  publisher =	 {Cambridge Press University \& Sigs Books},
  year =	 {1998}
}

@Book{		  czarnecki.00.book,
  oldkeys =      {czarnecki.00},
  author =	 {Krzysztof Czarnecki and Ulrich Eisenecker},
  title =	 {{Generative programming: Methods, Tools, and
                  Applications}},
  isbn =	 {0-201-30977-7},
  publisher =	 {ACM Press/Addison-Wesley Publishing Co.},
  address =	 {New York, NY, USA},
}

@InProceedings{	  day.95.oopsla,
  author =	 {Mark Day and Robert Gruber and Barbara Liskov and
                  Andrew C. Meyers},
  title =	 {Subtypes vs. where clauses: Constraining parametric
                  polymorphism},
  booktitle =	 {In the Proceedings of the ACM Conference on
                  Object-Oriented Programming Systems, Languages and
                  Applications (OOPSLA)},
  year =	 {1995},
  pages =	 {156--168},
  series =	 {SIGPLAN Notices volume 30 number 10},
}

@InProceedings{	  detlefs.99.ecoop,
  author =	 {David Detlefs and Ole Agesen},
  title =	 {Inlining of Virtual Methods},
  booktitle =	 {In the Proceedings of the 13th European Conference
                  on Object-Oriented Programming ({ECOOP})},
  year =	 {1999},
  month =	 {June},
  address =	 {Lisbon, Portugal}
}

@InProceedings{	  driesen.96.oopsla,
  author =	 {Karel Driesen and Urs H{\"o}lzle},
  title =	 {The Direct Cost of Virtual Function Calls in {C++}},
  booktitle =	 {In the Proceedings of the ACM Conference on
                  Object-Oriented Programming Systems, Languages and
                  Applications (OOPSLA)},
  pages =	 {306--323},
  year =	 {1996},
  series =	 {SIGPLAN Notices 31(10)},
  abstract =	 {We study the direct cost of virtual function calls
                  in C++ programs, assuming the standard
                  implementation using virtual function tables. We
                  measure this overhead experimentally for a number of
                  large benchmark programs, using a combination of
                  executable inspection and processor simulation. Our
                  results show that the C++ programs measured spend a
                  median of 5.2\% of their time and 3.7\% of their
                  instructions in dispatch code. For "all virtuals"
                  versions of the programs, the median overhead rises
                  to 13.7\% (13\% of the instructions). The "thunk"
                  variant of the virtual function table implementation
                  reduces the overhead by a median of 21\% relative to
                  the standard implementation. On future processors,
                  these overheads are likely to increase moderately.}
}

@Article{	  fabri.00.spe,
  author =	 {Andreas Fabri and Geert-Jan Giezeman and Lutz
                  Kettner and Stefan Schirra and Sven Sch{\"o}nherr},
  title =	 {On the Design of {CGAL} a Computational Geometry
                  Algorithms Library},
  journal =	 {Software - Practice and Experience},
  year =	 {2000},
  volume =	 {30},
  number =	 {11},
  pages =	 {1167--1202},
  citation =	 {Design goals are correctness, robustness,
                  flexibility (modularity, adaptability,
                  extensibility, openness), ease of use (smooth
                  learning curve, uniformity, complete and minimal
                  interfaces, rich and complete functionality), and
                  efficiency}
}

@Article{	  furnish.97.cip,
  author =	 {Geoffrey Furnish},
  title =	 {Disambiguated Glommable Expression Templates},
  journal =	 {Computers in Physics},
  year =	 1997,
  volume =	 11,
  number =	 3,
  pages =	 {263--269},
  abstract =	 {Extends the work of Veldhuizen and Haney, showing
                  how to attach expression templates to existing
                  containers, and how to keep terminals of
                  incompatible types out of individual expression
                  template statements.},
}

@Book{gamma.95.dp,
  oldkeys =      {Gamma1995, gamma95.dp},
  author =	 {Erich Gamma and Richard Helm and Ralph Johnson and
                  John Vlissides},
  title =	 {Design Patterns: {E}lements of Reusable
                  Object-Oriented Software},
  year =	 {1995},
  publisher =	 {{Addison-Wesley} Publishing Company},
  series =	 {{Addison-Wesley} Professional Computing Series},
  address =	 {New York, NY},
  lrdedoc =      {comp/prog/pattern/gamma.95.dp},
}

@InProceedings{garcia.03.oopsla,
  author =	 {Ronald Garcia and Jaakko Jarvi and Andrew Lumsdaine
                  and Jeremy G. Siek and Jeremiah Willcock},
  title =	 {A comparative study of language support for generic
                  programming},
  booktitle =	 {OOPSLA '03: Proceedings of the 18th annual ACM
                  SIGPLAN conference on Object-oriented programing,
                  systems, languages, and applications},
  year =	 {2003},
  isbn =	 {1-58113-712-5},
  pages =	 {115--134},
  location =	 {Anaheim, California, USA},
  doi =		 {http://doi.acm.org/10.1145/949305.949317},
  publisher =	 {ACM Press},
  address =	 {New York, NY, USA},
}

@Proceedings{	  gp.98.proc,
  title =	 {Generic Programming: International Seminar, Dagstuhl
                  Castle, Germany, 1998, Selected Papers},
  year =	 {2000},
  editor =	 {M. Jazayeri and R. Loos and D. Musser},
  volume =	 {1766},
  series =	 {Lecture Notes in Computer Science},
  publisher =	 {Springer-Verlag}
}

@Misc{		  gurtovoy.02.boost,
  author =	 {A. Gurtovoy and D. Abrahams},
  institution =	 {{Boost}},
  oldkeys =	 {mpl},
  title =	 {The Boost {C++} Metaprogramming Library},
  year =	 {2002},
  month =	 {March},
  note =	 {\url{http://www.boost.org}},
}

@Article{	  haney.96.cip,
  author =	 {Scott W. Haney},
  title =	 {Beating the Abstraction Penalty in {C++} Using
                  Expression Templates},
  journal =	 {Computers in Physics},
  year =	 {1996},
  volume =	 10,
  number =	 6,
  pages =	 {552--557}
}

@InProceedings{	  jarvi.01.tmpw,
  author =	 {Jaakko J\"arvi and Gary Powell},
  title =	 {The Lambda Library: Lambda Abstraction in {C++}},
  booktitle =	 {In the Proceedings of the 2nd Workshop on Template
                  Programming (in conjunction with OOPSLA)},
  year =	 {2001},
  address =	 {Tampa Bay, Florida, USA},
  month =	 {October}
}

@InProceedings{	  jazayeri.95.esec,
  author =	 {Mehdi Jazayeri},
  title =	 {Component Programming: a Fresh Look at Software
                  Components},
  booktitle =	 {In the Procedings of the 5th European Software
                  Engineering Conference (ESEC)},
  year =	 {1995},
  pages =	 {457--478},
  month =	 {September}
}

@Misc{		  langer.00.oopsla,
  author =	 {Angelika Langer},
  title =	 {Implementing Design Patterns Using {C++} Templates},
  howpublished = {Tutorial at the ACM Conference on Object-Oriented
                  Programming, Systems, Languages, and Applications
                  (OOPSLA)},
  month =	 {October},
  year =	 {2000},
  address =	 {Minneapolis, USA}
}

@Article{	  liskov.77.cacm,
  author =	 {Barbara Liskov and Alan Snyder and Russell Atkinson
                  and J. Craig Schaffert},
  title =	 {Abstraction Mechanisms in {CLU}},
  journal =	 {Communications of the ACM},
  year =	 {1977},
  volume =	 {20},
  number =	 {8},
  pages =	 {564--576},
  month =	 {August}
}

@TechReport{	  liskov.95.theta,
  author =	 {Barbara Liskov and Dorothy Curtis and Mark Day and
                  Sanjay Ghemawhat and Robert Gruber and Paul Johnson
                  and Andrew C. Myers},
  title =	 {Theta Reference Manual},
  institution =	 {Programming Methodology Group, MIT Laboratory for
                  Computer Science},
  address =	 {Cambridge, MA, USA},
  year =	 {1995},
  number =	 {88},
  month =	 {February}
}

@InProceedings{	  mcnamara.00.tmpw,
  author =	 {Brian McNamara and Yannis Smaragdakis},
  title =	 {Static Interfaces in {C++}},
  booktitle =	 {First Workshop on {C++} Template Programming,
                  Erfurt, Germany},
  month =	 {October 10},
  year =	 {2000},
  abstract =	 {We present an extensible framework for defining and
                  using ``static interfaces'' in C++. Static
                  interfaces are especially useful as constraints on
                  template parameters. That is, in addition to the
                  usual template $class T$, template definitions can
                  specify that T ``isa'' Foo, for some static
                  interface named Foo. These ``isa-constraints'' can
                  be based on either inheritance (named conformance: T
                  publicly inherits Foo), members (structural
                  conformance: T has these member functions with these
                  signatures), or both. The constraint mechanism
                  imposes no space or time overheads at runtime;
                  virtual functions are conspicuously absent from our
                  framework. We demonstrate two key utilities of
                  static interfaces. First, constraints enable better
                  error messages with template code. By applying
                  static interfaces as constraints, instantiating a
                  template with the wrong type is an error that can be
                  caught at the instantiation point, rather than later
                  (typically in the bowels of the
                  implementation). Authors of template classes and
                  template functions can also dispatch ``custom error
                  messages'' to report named constraint violations by
                  clients, making debugging easier. We show examples
                  of the improvement of error messages when
                  constraints are applied to STL code. Second,
                  constraints enable automatic compile-time dispatch
                  of different implementations of class or function
                  templates based on the named conformance properties
                  of the template types. For example, $Set<T>$ can be
                  written to automatically choose the most efficient
                  implementation: use a hashtable implementation if
                  ``T isa Hashable'', or else a binary search tree if
                  ``T isa LessThanComparable'' , or else a linked-list
                  if merely ``T isa EqualityComparable''. This
                  dispatch can be completely hidden from clients of
                  Set, who just use $Set<T>$ as usual.},
}

@InProceedings{meyer.86.oopsla,
  author =	 {Bertrand Meyer},
  title =	 {Genericity versus Inheritance},
  booktitle =	 {Proceedings of the Conference on Object Oriented
                  Programming Systems Languages and Aplications
                  (OOPSLA)},
  pages =	 {391--405},
  year =	 {1986},
  address =	 {Portland, OR, USA},
}

@Book{		  meyer.92.eiffel,
  author =	 {Bertrand Meyer},
  title =	 {Eiffel: the Language},
  publisher =	 {Prentice Hall},
  year =	 {1992}
}

@Article{meyers.00.cuj,
  author =	 {Scott Meyers},
  title =	 {How Non-Member Functions Improve Encapsulation},
  journal =	 j-CCCUJ,
  volume =	 {18},
  number =	 {2},
  pages =	 {44--??},
  month =	 feb,
  year =	 {2000},
  CODEN =	 {CCUJEX},
  ISSN =	 {1075-2838},
  bibdate =	 {Tue May 14 18:09:25 MDT 2002},
  bibsource =
                  {http://www.cuj.com/articles/2000/0002/0002toc.htm?topic=articles},
  abstract =	 {When it comes to encapsulation, sometimes less is
                  more.},
}

@Article{	  myers.95.cppr,
  author =	 {Nathan C. Myers},
  title =	 {Traits: a new and useful template technique},
  journal =	 {C++ Report},
  year =	 {1995},
  volume =	 {7},
  number =	 {5},
  pages =	 {32--35},
  month =	 jun
}

@InProceedings{	  myers.97.popl,
  author =	 {Andrew C. Myers and Joseph A. Bank and Barbara
                  Liskov},
  title =	 {Parameterized Types for Java},
  booktitle =	 {In the Proceedings of the 24th ACM Symposium on
                  Principles of Programming Languages (POPL)},
  pages =	 {132-145},
  year =	 {1997},
  address =	 {Paris, France},
  month =	 {January}
}

@Misc{		  olena.www,
  oldkeys =	 {olena.net},
  title =	 {Olena image processing library},
  key =		 {Olena},
  url =		 {http://olena.lrde.epita.fr},
  year =	 {2003}
}

@Misc{		  oonumerics.www,
  oldkeys =	 {oonumerics.net},
  title =	 {Scientific computing in object-oriented languages},
  key =		 {oonumerics},
  url =		 {http://www.oonumerics.org},
  year =	 2003
}

@Article{	  palsberg.94.scp,
  author =	 {Jens Palsberg and Michael I. Schwartzbach},
  title =	 {Static typing for object-oriented programming},
  journal =	 {Science of Computer Programming},
  year =	 {1994},
  volume =	 {23},
  number =	 {1},
  pages =	 {19--53}
}

@Unpublished{remy.00.virtual,
  author =	 {Xavier R\'emy and J\'er\^ome Vouillon},
  title =	 {On the (Un)reality of Virtual Types},
  month =	 {March},
  year =	 {2000},
  url =		 {http://pauillac.inria.fr/~remy/work/virtual/}
}

@InProceedings{	  schultz.01.lncs,
  author =	 {Ulrik P. Schultz},
  booktitle =	 {Program as Data Objects: International Conference on
                  the Theory and Application of Cryptographic
                  Techniques, Innsbruck, Austria, May 2001,
                  Proceedings},
  title =	 {Partial Evaluation for Class-Based Object-Oriented
                  Languages},
  series =	 {Lecture Notes in Computer Science},
  volume =	 {2053},
  pages =	 {173--198},
  year =	 {2001},
  publisher =	 {Springer-Verlag},
}

@InProceedings{	  seidewitz.94.oopsla,
  author =	 {Ed Seidewitz},
  title =	 {Genericity versus Inheritance Reconsidered:
                  Self-Reference using Generics},
  booktitle =	 {In the Proceedings of the 9th Conference on Object
                  Oriented Programming Systems Languages and
                  Aplications (OOPSLA)},
  pages =	 {153--163},
  year =	 {1994},
  address =	 {Portland, OR, USA},
  month =	 {October},
  abstract =	 {As shown by the work of Bertrand Meyer, it is
                  possible to simulate genericity using inheritance,
                  but not vice-versa. This is because genericity is a
                  parameterization mechanism with no way to deal with
                  the polymorphic typing introduced using
                  inheritance. Nevertheless, if we focus on the use of
                  inheritance as an implementation technique, its key
                  feature is the dynamic binding of self-referential
                  operation calls. This turns out to be basically a
                  parameterization mechanism that can in fact be
                  simulated using generics and static binding. And for
                  some applications this approach may actually be of
                  more than academic interest. --------------------
                  This paper discusses how the use of generics for the
                  static-binding of self-referential calls is
                  important in the comparison of inheritance and
                  genericity. It discusses how the generic approach
                  gives the programmer much more precise control about
                  when and where self-referential bindings are made
                  and thus makes the use and intent of self-reference
                  more apparent to the software maintainer. The paper
                  notes that the generic approach provides
                  self-reference and deferred operation implementation
                  with fully static binding, thus avoiding the
                  suspicion with which many dynamic constructs are
                  regarded. The paper shows how inheritance can be
                  simulated by type plus polymorphic typing plus
                  genericity, and that the generic approach has some
                  potential advantages. }
}

@InProceedings{	  siek.00.tmpw,
  author =	 {Jeremy Siek and Andrew Lumsdaine},
  title =	 {Concept Checking: Binding Parametric Polymorphism in
                  {C++}},
  booktitle =	 {Proceedings of the First Workshop on {C++} Template
                  Programming},
  address =	 {Erfurt, Germany},
  month =	 {October},
  year =	 {2000},
  abstract =	 {Generic programming in C++ is characterized by the
                  use of template parameters to represent abstract
                  data types (or ``concepts''). However, the C++
                  language itself does not provide a mechanism for
                  explicitly handling concepts. As a result, it can be
                  difficult to insure that a concrete type meets the
                  requirements of the concept it is supposed to
                  represent. Error messages resulting from incorrect
                  use of a concrete type can be particularly difficult
                  to decipher. In this paper we present techniques to
                  check parameters in generic C++ libraries. Our
                  techniques use standard C++ and introduce no
                  run-time overhead.}
}

@InProceedings{    siek.04.clfpg,
  author =	{Jeremy G. Siek and Andrew Lumsdaine},
  title =	{Modular Generics},
  booktitle =	{Concepts: a Linguistic Foundation of Generic Programming},
  year =	2004,
  month =	{April},
  organization = {{Adobe Systems}},
  annote =	{This paper presents the design of G, a new language
                  specifically created for generic programming. We
                  review and identify important language features of
                  C++ and Haskell in light of the past decade of
                  generic library research and development. Based on
                  this analysis we propose and evaluate relevant
                  language design decisions for G. Generic programming
                  is concerned with the construction of libraries of
                  reusable software components and is inherently about
                  programming ``in the large.'' Thus, the design of G
                  places its greatest emphasis on modularity and
                  safety, while also providing run-time efficiency and
                  programmer convenience. This paper focuses on name
                  scoping and type checking for generic functions,
                  support for dispatching to algorithm
                  specializations, support for type associations among
                  abstractions, and separate compilation. The
                  resulting design for G includes three novel aspects:
                  scoped models declarations, nested types in
                  concepts, and optional type constraints on generic
                  functions.}
}

@InProceedings{	  smaragdakis.00.gcse,
  author =	 {Yannis Smaragdakis and Don Batory},
  title =	 {Mixin-Based Programming in {C++}},
  booktitle =	 {In the Proceedings of the 2nd International
                  Conference on Generative and Component-based
                  Software Engineering (GCSE)},
  pages =	 {464--478},
  year =	 {2000},
  month =	 {October},
  publisher =	 {tranSIT Verlag, Germany}
}

@Article{	  smaragdakis.02.spe,
  author =	 {Yannis Smaragdakis and Brian McNamara},
  title =	 {{FC++}: Functional Tools for Object-Oriented Tasks},
  journal =	 {Software - Practice and Experience},
  year =	 {2002},
  volume =	 {32},
  number =	 {10},
  pages =	 {1015--1033},
  month =	 {August}
}

@Article{	  smith.03.accu,
  author =	 {Julian Smith},
  title =	 {{C++} \& Multi-Methods},
  journal =	 {ACCU spring 2003 conference},
  year =	 2003
}

@Book{		  stepanov.00.book,
  author =	 {Alexander Stepanov and Meng Lee and David Musser},
  title =	 {The {C++} Standard Template Library},
  publisher =	 {Prentice-Hall},
  year =	 {2000}
}

@InProceedings{	  striegnitz.00.tmpw,
  author =	 {J\"org Striegnitz and Stephen A. Smith},
  title =	 {An Expression Template Aware Lambda Function},
  booktitle =	 {In the Proceedings of the 1st Workshop on Template
                  Programming},
  year =	 {2000},
  address =	 {Erfurt, Germany},
  month =	 {October}
}

@InProceedings{	  stroustrup.88.cpp,
  author =	 {Bjarne Stroustrup},
  title =	 {Parameterized Types for {C++}},
  booktitle =	 {In the Proceedings of the USENIX C++ Conference},
  year =	 {1988},
  month =	 {October},
  address =	 {Denver, USA}
}

@Book{		  stroustrup.94.dne,
  author =	 {Bjarne Stroustrup},
  title =	 {The Design and Evolution of {C++}},
  publisher =	 {ACM Press/Addison-Wesley Publishing Co.},
  isbn =	 {0-201-54330-3},
  year =	 {1994},
}

@InProceedings{	  stroustrup.95.oopsla,
  author =	 {Bjarne Stroustrup},
  title =	 {Why {C++} isn't just an Object-Oriented Programming
                  Language},
  booktitle =	 {In the Proceedings of the ACM Conference on
                  Object-Oriented Programming Systems, Languages and
                  Applications (OOPSLA)},
  year =	 {1995},
  month =	 {October}
}

@Misc{		  surazhsky.02,
  oldkeys =      {surazhsky02},
  author =	 {Vitaly Surazhsky and Joseph Y. Gil},
  title =	 {Type-Safe Covariance in {C}++},
  year =	 {2002},
  url =
                  {http://www.cs.technion.ac.il/~yogi/Courses/CS-Scientific-Writing/examples/paper/main.pdf},
  note =	 {Unpublished},
}

@inproceedings{thorup.97.ecoop,
  author =	 {Kresten Krab Thorup},
  title =	 {Genericity in {J}ava with Virtual Types},
  volume =	 {1241},
  series =	 {Lecture Notes in Computer Science},
  pages =	 {444--471},
  booktitle =	 {Proceedings of the 11th European Conference on
                  Object-Oriented Programming (ECOOP)},
  year =	 {1997},
  month =	 {June},
  address =	 {Jyv\"askyl\"a, Finland},
  publisher =	 {Springer-Verlag},
}

@InProceedings{	  thorup.99.ecoop,
  author =	 {Kresten Krab Thorup and Mads Torgersen},
  title =	 {Unifying Genericity: Combining the benefits of
                  virtual types and parameterized classes},
  booktitle =	 {In the Proceedings of the 13th European Conference
                  on Object-Oriented Programming (ECOOP)},
  pages =	 {186--204},
  year =	 {1999},
  editor =	 {Rachid Guerraoui},
  volume =	 {1628},
  series =	 {Lecture Notes in Computer Science},
  address =	 {Lisbon, Portugal},
  month =	 {June},
  publisher =	 {Springer-Verlag}
}

@InProceedings{	  torgersen.98.fool,
  author =	 {Mads Torgersen},
  title =	 {Virtual Types are Statically Safe},
  booktitle =	 {In the Proceedings of the 5th Workshop on
                  Foundations of Object-Oriented Languages (FOOL)},
  year =	 {1998},
  month =	 {January},
  address =	 {San Diego, CA},
  abstract =	 {Virtual types are a combined genericity and
                  covariance mechanism first introduced in BETA. Like
                  most other covariant language constructs, virtual
                  types in their original form depend on dynamic
                  checking for type safety. This paper presents full
                  statical type checking for virtual types, while not
                  relying on any other special language mechanisms for
                  safety. Good expressiveness is retained, as
                  demonstrated by a simple but effective solution to
                  the infamous ColourPoint problem.}
}

@Book{		  vandevoorde.03.book,
  author =	 {David Vandevoorde and Nicolai M. Josuttis},
  title =	 {{C++} Templates: The Complete Guide},
  publisher =	 {Addison-Wesley},
  year =	 {2003}
}

@Article{veldhuizen.95.c++,
  oldkeys =      {Veldhuizen95b},
  author =	 "Todd L. Veldhuizen",
  title =	 "Expression templates",
  journal =	 "C++ Report",
  volume =	 "7",
  number =	 "5",
  pages =	 "26--31",
  month =	 jun,
  year =	 "1995",
  note =	 "Reprinted in C++ Gems, ed. Stanley Lippman",
  coden =	 "CRPTE7",
  ISSN =	 "1040-6042",
  bibdate =	 "Tue Mar 25 13:34:48 MST 1997",
  abstract =	 "The technique of expression templates is a powerful
                  and convenient alternative to C-style callback
                  functions. It allows logical and algebraic
                  expressions to be passed to functions as arguments,
                  and inlined directly into the function
                  body. Expression templates also solve the problem of
                  evaluating vector and matrix expressions in a single
                  pass without temporaries.",
  acknowledgement =ack-nhfb,
  affiliation =	 "Dept. of Syst. Design Eng., Waterloo Univ., Ont.,
                  Canada",
  classcodes =	 "C6110J (Object-oriented programming); C6115
                  (Programming support); C4140 (Linear algebra); C6120
                  (File organisation)",
  classification ="C4140 (Linear algebra); C6110J (Object-oriented
                  programming); C6115 (Programming support); C6120
                  (File organisation)",
  corpsource =	 "Dept. of Syst. Design Eng., Waterloo Univ., Ont.,
                  Canada",
  keywords =	 "abstract data types; Algebraic expressions;
                  algebraic expressions; Arguments; arguments; C
                  language; C-style callback functions; Expression
                  templates; expression templates; expressions;
                  libraries; logical; Logical expressions; matrix;
                  matrix algebra; Matrix expressions; object-;
                  object-oriented programming; oriented languages;
                  Single pass; single pass; software; Vector
                  expressions; vector expressions",
  thesaurus =	 "Abstract data types; C language; Matrix algebra;
                  Object-oriented languages; Object-oriented
                  programming; Software libraries",
  treatment =	 "T Theoretical or Mathematical",
}

@InProceedings{	  veldhuizen.00.tmpw,
  author =	 {Todd L. Veldhuizen},
  title =	 {Five Compilation Models for {C++} Templates},
  booktitle =	 {In the Proceedings of the 1st Workshop on {C++}
                  Template Programming, Erfurt, Germany},
  month =	 {October},
  year =	 {2000},
  abstract =	 {This paper proposes an alternate structure for C++
                  compilers. Type analysis is removed from the
                  compiler and replaced with a `type system library'
                  which is treated as source code by the
                  compiler. Type computations are embedded in the
                  intermediate language of the compiler, and partial
                  evaluation is used to drive type analysis and
                  template instantiation. By making simple changes to
                  the behavior of the partial evaluator, a wide range
                  of compilation models is achieved, each with a
                  distinct tradeoff of compile time, code size, and
                  code speed. These models range from pure dynamic
                  typing -- ideal for scripting C++ -- to
                  profile-directed template instantiation. This
                  approach may solve several serious problems in
                  compiling C++: it achieves separate compilation of
                  templates, allows template code to be distributed in
                  binary form by deferring template instantiation
                  until run time, and reduces the code bloat
                  associated with templates.}
}

@InProceedings{	  veldhuizen.02.sas,
  author =	 {Todd L. Veldhuizen and Andrew Lumsdaine},
  title =	 {Guaranteed Optimization: Proving Nullspace
                  Properties of Compilers},
  booktitle =	 {Static Analysis, 9th International Symposium, SAS
                  2002, Madrid, Spain, September 17-20, 2002,
                  Proceedings},
  pages =	 {263--277},
  year =	 {2002},
  volume =	 {2477},
  series =	 {Lecture Notes in Computer Science},
  publisher =	 {Springer-Verlag},
  abstract =	 {Writing performance-critical programs can be
                  frustrating be-cause optimizing compilers for
                  imperative languages tend to be unpre-dictable. For
                  a subset of optimizations those that simplify rather
                  than reorder code it would be useful to prove that a
                  compiler reliably per-forms optimizations. We show
                  that adopting a superanalysis approach to
                  optimization enables such a proof. By analogy with
                  linear algebra, we define the nullspace of an
                  optimizer as those programs it reduces to the empty
                  program. To span the nullspace, we define rewrite
                  rules that de-optimize programs by introducing
                  abstraction. For a model compiler we prove that any
                  sequence of de-optimizing rewrite rule applications
                  is undone by the optimizer. Thus, we are able to
                  give programmers a clear mental model of what
                  simplifications the compiler is guaranteed to
                  perform, and make progress on the problem of
                  abstraction penalty in imperative languages.}
}

@InBook{	  veldhuizen.98.cppgems,
  author =	 {Todd Veldhuizen},
  title =	 {Expression Templates},
  booktitle =	 {{C++} Gems},
  pages =	 {475--487},
  note =	 {In~\cite{cppgems}}
}

@Misc{		  veldhuizen.99.tech,
  author =	 {Todd L. Veldhuizen},
  title =	 {Techniques for Scientific {C++}},
  month =	 {August},
  year =	 {1999},
  url =
                  {http://extreme.indiana.edu/~tveldhui/papers/techniques/}
}

@Misc{		  xt,
  key =		 {Xt},
  year =	 {2003},
  title =	 {A Bundle of Program Transformation Tools},
  howpublished = {Available on the Internet},
  url =		 {http://www.program-transformation.org/xt}
}

@InProceedings{	  zendra.97.oopsla,
  author =	 {Olivier Zendra and Dominique Colnet and Suzanne
                  Collin},
  title =	 {{E}fficient {D}ynamic {D}ispatch without {V}irtual
                  {F}unction {T}ables. {T}he {S}mall{E}iffel
                  {C}ompiler.},
  booktitle =	 {In the Proceedings of the 12th ACM Conference on
                  Object-Oriented Programming Systems, Languages and
                  Applications (OOPSLA)},
  pages =	 {125--141},
  year =	 {1997},
  volume =	 {32},
  series =	 {Issue 10},
  address =	 {Athlanta, GA, USA},
  month =	 {October},
  annote =	 {Abstract: SmallEiffel is an Eiffel compiler which
                  uses a fast simple inference mechanism to remove
                  most last binding calls, replacing them by static
                  bindings. Starting from the system's entry point, it
                  compiles only statically living code, which saves
                  compiling and then removing dead code. As the whole
                  system is analyzed at compile time, multiple
                  inheritance and genericity do not cause any
                  overhead. SmallEiffel features a coding scheme which
                  eliminates the need for virtual function
                  tables. Dynamic dispatch is implemented without any
                  array access but uses a simple static binary branch
                  code. We show that this implementation makes it
                  possible to use modern hardware very efficiently. It
                  also allows to inline more calls even when dynamic
                  dispatch is required. Some more dispatch sites are
                  removed after the type inference algorithm has been
                  performed, if the different branches of a dispatch
                  site lead to the same code. The advantage of this
                  approach is that it greatly speeds up execution time
                  and considerably decreases the amount of generated
                  code.}
}
